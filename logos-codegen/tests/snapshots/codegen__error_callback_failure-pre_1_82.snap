---
source: logos-codegen/tests/codegen.rs
expression: generated
---
impl < 's > :: logos :: Logos < 's > for TokenA { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) { fn _logos_derive_compile_errors () { { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("expected one of: `for`, parentheses, `fn`, `unsafe`, `extern`, identifier, `::`, `<`, `dyn`, square brackets, `*`, `&`, `!`, `impl`, `_`, lifetime") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Expected a named argument at this position\n\nhint: If you are trying to define a callback here use: callback = ...") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Expected: #[logos(error = SomeType)] or #[logos(error(SomeType[, callback))]") } { compile_error ! ("Callback missing a body") } { compile_error ! ("Not a valid callback") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Expected: callback = ...") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Callback has been already set") } { compile_error ! ("Previous callback set here") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } { compile_error ! ("Unknown nested attribute: unknown_attribute\n\nExpected one of: callback") } { compile_error ! ("Error type can be defined only once") } { compile_error ! ("Previous definition here") } } } # [inline] fn make_error (mut lex : & mut :: logos :: Lexer < 's , Self >) { use :: logos :: { Lexer , internal :: LexerInternal } ; let error = callback4 (& mut lex) ; lex . set (Err (error)) ; } }

---
source: logos-codegen/tests/codegen.rs
expression: generated
---
impl < 's > :: logos :: Logos < 's > for Token < 's > { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) { use :: logos :: internal :: { LexerInternal , CallbackResult , SkipCallbackResult } ; type Lexer < 's > = :: logos :: Lexer < 's , Token < 's > > ; fn _end < 's > (lex : & mut Lexer < 's >) { lex . end () } fn _error < 's > (lex : & mut Lexer < 's >) { lex . bump_unchecked (1) ; lex . error () ; } macro_rules ! _fast_loop { ($ lex : ident , $ test : ident , $ miss : expr) => { while let Some (arr) = $ lex . read :: < & [u8 ; 16] > () { if $ test (arr [0]) { if $ test (arr [1]) { if $ test (arr [2]) { if $ test (arr [3]) { if $ test (arr [4]) { if $ test (arr [5]) { if $ test (arr [6]) { if $ test (arr [7]) { if $ test (arr [8]) { if $ test (arr [9]) { if $ test (arr [10]) { if $ test (arr [11]) { if $ test (arr [12]) { if $ test (arr [13]) { if $ test (arr [14]) { if $ test (arr [15]) { $ lex . bump_unchecked (16) ; continue ; } $ lex . bump_unchecked (15) ; return $ miss ; } $ lex . bump_unchecked (14) ; return $ miss ; } $ lex . bump_unchecked (13) ; return $ miss ; } $ lex . bump_unchecked (12) ; return $ miss ; } $ lex . bump_unchecked (11) ; return $ miss ; } $ lex . bump_unchecked (10) ; return $ miss ; } $ lex . bump_unchecked (9) ; return $ miss ; } $ lex . bump_unchecked (8) ; return $ miss ; } $ lex . bump_unchecked (7) ; return $ miss ; } $ lex . bump_unchecked (6) ; return $ miss ; } $ lex . bump_unchecked (5) ; return $ miss ; } $ lex . bump_unchecked (4) ; return $ miss ; } $ lex . bump_unchecked (3) ; return $ miss ; } $ lex . bump_unchecked (2) ; return $ miss ; } $ lex . bump_unchecked (1) ; return $ miss ; } return $ miss ; } while $ lex . test ($ test) { $ lex . bump_unchecked (1) ; } $ miss } ; } # [inline] fn goto1_ctx1_x < 's > (lex : & mut Lexer < 's >) { let token = Token :: Integer (lex . slice ()) ; lex . set (Ok (token)) ; } # [inline] fn goto1_x < 's > (lex : & mut Lexer < 's >) { let token = Token :: Integer (lex . slice ()) ; lex . set (Ok (token)) ; } # [inline] fn goto5_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto4_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto71_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (1usize) { Some ([188u8 , 144u8 ..= 153u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto5_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto28_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([144u8 ..= 153u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto4_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto3_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn pattern0 (byte : u8) -> bool { match byte { 144u8 ..= 153u8 | 176u8 ..= 185u8 => true , _ => false , } } # [inline] fn goto66_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match byte { byte if pattern0 (byte) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto70_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J28 , J4 , J3 , J66 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J28 , J5 , __ , __ , J66 , __ , J28 , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at2_ctx1_x (lex) , Jump :: J28 => goto28_at2_ctx1_x (lex) , Jump :: J4 => goto4_at2_ctx1_x (lex) , Jump :: J3 => goto3_at2_ctx1_x (lex) , Jump :: J66 => goto66_at2_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto5_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto4_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto28_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([144u8 ..= 153u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto192_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([177u8 ..= 186u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto195_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J28 , J192 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J5 , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , J192 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3_ctx1_x (lex) , Jump :: J4 => goto4_at3_ctx1_x (lex) , Jump :: J28 => goto28_at3_ctx1_x (lex) , Jump :: J192 => goto192_at3_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto69_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([175u8 , 176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto174_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([179u8 , 176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto3_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto81_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , J5 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3_ctx1_x (lex) , Jump :: J4 => goto4_at3_ctx1_x (lex) , Jump :: J3 => goto3_at3_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto93_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([182u8 ..= 191u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto9_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([166u8 ..= 175u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn pattern1 (byte : u8) -> bool { match byte { 128u8 ..= 137u8 | 144u8 ..= 163u8 => true , _ => false , } } # [inline] fn goto123_at3_ctx1_x < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (3usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match byte { byte if pattern1 (byte) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto153_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J93 , J4 , J28 , J9 , J123 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J9 , __ , J4 , J93 , __ , __ , J28 , __ , __ , __ , J4 , __ , __ , __ , __ , __ , J28 , __ , J28 , __ , __ , __ , __ , __ , J28 , __ , J123 , J4 , __ , __ , __ , __ , __ , __ , J3 , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , __ , J28 , __ , __ , __ , J28 , J3 , __ , __ , __ , __ , __ , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J93 => goto93_at3_ctx1_x (lex) , Jump :: J4 => goto4_at3_ctx1_x (lex) , Jump :: J28 => goto28_at3_ctx1_x (lex) , Jump :: J9 => goto9_at3_ctx1_x (lex) , Jump :: J123 => goto123_at3_ctx1_x (lex) , Jump :: J3 => goto3_at3_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto171_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J28 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , J5 , __ , J28 , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3_ctx1_x (lex) , Jump :: J4 => goto4_at3_ctx1_x (lex) , Jump :: J28 => goto28_at3_ctx1_x (lex) , Jump :: J3 => goto3_at3_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto177_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([159u8 , 142u8 ..= 191u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto197_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J195 , J69 , J174 , J81 , J153 , J171 , J177 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J81 , J153 , __ , __ , __ , __ , J171 , __ , __ , __ , __ , __ , J174 , J177 , J195 , J69 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J195 => goto195_at2_ctx1_x (lex) , Jump :: J69 => goto69_at2_ctx1_x (lex) , Jump :: J174 => goto174_at2_ctx1_x (lex) , Jump :: J81 => goto81_at2_ctx1_x (lex) , Jump :: J153 => goto153_at2_ctx1_x (lex) , Jump :: J171 => goto171_at2_ctx1_x (lex) , Jump :: J177 => goto177_at2_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto9_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([166u8 ..= 175u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto32_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J9 , J28 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J28 , __ , J28 , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J9 => goto9_at2_ctx1_x (lex) , Jump :: J28 => goto28_at2_ctx1_x (lex) , Jump :: J3 => goto3_at2_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto3_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn pattern2 (byte : u8) -> bool { match byte { 128u8 ..= 137u8 | 144u8 ..= 153u8 => true , _ => false , } } # [inline] fn goto49_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match byte { byte if pattern2 (byte) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto42_at2_ctx1_x < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([134u8 ..= 143u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => goto1_x (lex) , } } # [inline] fn goto57_at1_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J28 , J4 , J49 , J3 , J42 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J5 , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , J28 , __ , __ , __ , __ , J42 , __ , J28 , __ , __ , J49 , __ , __ , J28 , J4 , __ , __ , J49 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return goto1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at2_ctx1_x (lex) , Jump :: J28 => goto28_at2_ctx1_x (lex) , Jump :: J4 => goto4_at2_ctx1_x (lex) , Jump :: J49 => goto49_at2_ctx1_x (lex) , Jump :: J3 => goto3_at2_ctx1_x (lex) , Jump :: J42 => goto42_at2_ctx1_x (lex) , Jump :: __ => goto1_x (lex) } } # [inline] fn goto2_ctx1_x < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J71 , J70 , J197 , J32 , J3 , J2 , J57 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , J4 , __ , __ , __ , J5 , J32 , J57 , __ , __ , __ , __ , __ , __ , __ , __ , J70 , __ , __ , __ , __ , J71 , J197 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read :: < u8 > () { Some (byte) => byte , None => return goto1_ctx1_x (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at1_ctx1_x (lex) , Jump :: J4 => goto4_at1_ctx1_x (lex) , Jump :: J71 => goto71_at1_ctx1_x (lex) , Jump :: J70 => goto70_at1_ctx1_x (lex) , Jump :: J197 => goto197_at1_ctx1_x (lex) , Jump :: J32 => goto32_at1_ctx1_x (lex) , Jump :: J3 => goto3_at1_ctx1_x (lex) , Jump :: J2 => { lex . bump_unchecked (1usize) ; goto2_ctx1_x (lex) } , Jump :: J57 => goto57_at1_ctx1_x (lex) , Jump :: __ => goto1_ctx1_x (lex) } } # [inline] fn goto5_at1 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto4_at1 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto71_at1 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (1usize) { Some ([188u8 , 144u8 ..= 153u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto5_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto28_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([144u8 ..= 153u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto4_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto3_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto66_at2 < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match byte { byte if pattern0 (byte) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto70_at1 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J28 , J4 , J3 , J66 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J28 , J5 , __ , __ , J66 , __ , J28 , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at2 (lex) , Jump :: J28 => goto28_at2 (lex) , Jump :: J4 => goto4_at2 (lex) , Jump :: J3 => goto3_at2 (lex) , Jump :: J66 => goto66_at2 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto5_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([128u8 ..= 137u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto4_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto28_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([144u8 ..= 153u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto192_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([177u8 ..= 186u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto195_at2 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J28 , J192 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J5 , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , J192 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3 (lex) , Jump :: J4 => goto4_at3 (lex) , Jump :: J28 => goto28_at3 (lex) , Jump :: J192 => goto192_at3 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto69_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([175u8 , 176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto174_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([179u8 , 176u8 ..= 185u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto3_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto81_at2 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , J5 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3 (lex) , Jump :: J4 => goto4_at3 (lex) , Jump :: J3 => goto3_at3 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto93_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([182u8 ..= 191u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto9_at3 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (3usize) { Some ([166u8 ..= 175u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto123_at3 < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (3usize) { Some (byte) => byte , None => return _error (lex) , } ; match byte { byte if pattern1 (byte) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto153_at2 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J93 , J4 , J28 , J9 , J123 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J9 , __ , J4 , J93 , __ , __ , J28 , __ , __ , __ , J4 , __ , __ , __ , __ , __ , J28 , __ , J28 , __ , __ , __ , __ , __ , J28 , __ , J123 , J4 , __ , __ , __ , __ , __ , __ , J3 , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , __ , J28 , __ , __ , __ , J28 , J3 , __ , __ , __ , __ , __ , __ , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J93 => goto93_at3 (lex) , Jump :: J4 => goto4_at3 (lex) , Jump :: J28 => goto28_at3 (lex) , Jump :: J9 => goto9_at3 (lex) , Jump :: J123 => goto123_at3 (lex) , Jump :: J3 => goto3_at3 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto171_at2 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J28 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , J5 , __ , J28 , __ , __ , __ , __ , __ , __ , __ , J4 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at3 (lex) , Jump :: J4 => goto4_at3 (lex) , Jump :: J28 => goto28_at3 (lex) , Jump :: J3 => goto3_at3 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto177_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 2usize] > (2usize) { Some ([159u8 , 142u8 ..= 191u8]) => { lex . bump_unchecked (4usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto197_at1 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J195 , J69 , J174 , J81 , J153 , J171 , J177 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J81 , J153 , __ , __ , __ , __ , J171 , __ , __ , __ , __ , __ , J174 , J177 , J195 , J69 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J195 => goto195_at2 (lex) , Jump :: J69 => goto69_at2 (lex) , Jump :: J174 => goto174_at2 (lex) , Jump :: J81 => goto81_at2 (lex) , Jump :: J153 => goto153_at2 (lex) , Jump :: J171 => goto171_at2 (lex) , Jump :: J177 => goto177_at2 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto9_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([166u8 ..= 175u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto32_at1 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J9 , J28 , J3 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J9 , __ , J28 , __ , J28 , J3 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J9 => goto9_at2 (lex) , Jump :: J28 => goto28_at2 (lex) , Jump :: J3 => goto3_at2 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto3_at1 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (1usize) { Some ([160u8 ..= 169u8]) => { lex . bump_unchecked (2usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto49_at2 < 's > (lex : & mut Lexer < 's >) { let byte = match lex . read_at :: < u8 > (2usize) { Some (byte) => byte , None => return _error (lex) , } ; match byte { byte if pattern2 (byte) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto42_at2 < 's > (lex : & mut Lexer < 's >) { match lex . read_at :: < & [u8 ; 1usize] > (2usize) { Some ([134u8 ..= 143u8]) => { lex . bump_unchecked (3usize) ; goto2_ctx1_x (lex) } , _ => _error (lex) , } } # [inline] fn goto57_at1 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J28 , J4 , J49 , J3 , J42 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J5 , J28 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , J28 , __ , __ , __ , __ , J42 , __ , J28 , __ , __ , J49 , __ , __ , J28 , J4 , __ , __ , J49 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read_at :: < u8 > (1usize) { Some (byte) => byte , None => return _error (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at2 (lex) , Jump :: J28 => goto28_at2 (lex) , Jump :: J4 => goto4_at2 (lex) , Jump :: J49 => goto49_at2 (lex) , Jump :: J3 => goto3_at2 (lex) , Jump :: J42 => goto42_at2 (lex) , Jump :: __ => _error (lex) } } # [inline] fn goto198 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J4 , J71 , J70 , J197 , J32 , J3 , J2 , J57 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , J2 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J3 , __ , J4 , __ , __ , __ , J5 , J32 , J57 , __ , __ , __ , __ , __ , __ , __ , __ , J70 , __ , __ , __ , __ , J71 , J197 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read :: < u8 > () { Some (byte) => byte , None => return _end (lex) , } ; match LUT [byte as usize] { Jump :: J5 => goto5_at1 (lex) , Jump :: J4 => goto4_at1 (lex) , Jump :: J71 => goto71_at1 (lex) , Jump :: J70 => goto70_at1 (lex) , Jump :: J197 => goto197_at1 (lex) , Jump :: J32 => goto32_at1 (lex) , Jump :: J3 => goto3_at1 (lex) , Jump :: J2 => { lex . bump_unchecked (1usize) ; goto2_ctx1_x (lex) } , Jump :: J57 => goto57_at1 (lex) , Jump :: __ => _error (lex) } } goto198 (lex) } }

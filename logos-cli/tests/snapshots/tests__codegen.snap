---
source: logos-cli/tests/tests.rs
expression: output
---
# [derive (Debug , Clone , Copy , PartialEq)] enum Token { Letter , }impl < 's > :: logos :: Logos < 's > for Token { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) -> std :: option :: Option < std :: result :: Result < Self , Self :: Error >> { use :: logos :: internal :: { LexerInternal , CallbackRetVal , CallbackResult , SkipRetVal , SkipResult , } ; use std :: result :: Result as _Result ; use std :: option :: Option as _Option ; use :: logos :: Logos ; type _Lexer < 's > = :: logos :: Lexer < 's , Token > ; macro_rules ! _fast_loop { ($ lex : ident , $ test : ident , $ offset : ident) => { 'fast_loop : { while let Some (arr) = $ lex . read :: < & [u8 ; 16usize] > ($ offset) { if $ test (arr [0usize]) { $ offset += 0usize ; break 'fast_loop ; } if $ test (arr [1usize]) { $ offset += 1usize ; break 'fast_loop ; } if $ test (arr [2usize]) { $ offset += 2usize ; break 'fast_loop ; } if $ test (arr [3usize]) { $ offset += 3usize ; break 'fast_loop ; } if $ test (arr [4usize]) { $ offset += 4usize ; break 'fast_loop ; } if $ test (arr [5usize]) { $ offset += 5usize ; break 'fast_loop ; } if $ test (arr [6usize]) { $ offset += 6usize ; break 'fast_loop ; } if $ test (arr [7usize]) { $ offset += 7usize ; break 'fast_loop ; } if $ test (arr [8usize]) { $ offset += 8usize ; break 'fast_loop ; } if $ test (arr [9usize]) { $ offset += 9usize ; break 'fast_loop ; } if $ test (arr [10usize]) { $ offset += 10usize ; break 'fast_loop ; } if $ test (arr [11usize]) { $ offset += 11usize ; break 'fast_loop ; } if $ test (arr [12usize]) { $ offset += 12usize ; break 'fast_loop ; } if $ test (arr [13usize]) { $ offset += 13usize ; break 'fast_loop ; } if $ test (arr [14usize]) { $ offset += 14usize ; break 'fast_loop ; } if $ test (arr [15usize]) { $ offset += 15usize ; break 'fast_loop ; } $ offset += 16usize ; } while let Some (byte) = $ lex . read :: < u8 > ($ offset) { if $ test (byte) { break 'fast_loop ; } $ offset += 1 ; } } } ; } # [inline] fn _make_error < 's > (lex : & mut _Lexer < 's >) -> < Token as Logos < 's >> :: Error { < Token as Logos < 's >> :: Error :: default () } fn state1024_ctx0 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { other => { if other . is_none () { } return Some (Ok (Token :: Letter)) ; } } } fn state1536 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { match lex . read :: < u8 > (offset) { Some (b'a') => { offset += 1 ; return state3072 (lex , offset) ; } , other => { if other . is_none () { if lex . offset () == offset { return None } } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } } } fn state2048 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { match lex . read :: < u8 > (offset) { Some (b'z') => { offset += 1 ; return state2560 (lex , offset) ; } , other => { if other . is_none () { } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } } } fn state2560 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; return state1024_ctx0 (lex , offset) ; } , other => { if other . is_none () { offset += 1 ; return state1024_ctx0 (lex , offset) ; } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } } } fn state3072 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { match lex . read :: < u8 > (offset) { Some (b'-') => { offset += 1 ; return state2048 (lex , offset) ; } , other => { if other . is_none () { } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } } } state1536 (lex , lex . offset ()) } }

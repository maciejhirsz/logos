---
source: logos-codegen/tests/codegen.rs
expression: formatted
---
impl<'s> ::logos::Logos<'s> for Token {
    type Error = ();
    type Extras = ();
    type Source = [u8];
    fn lex(
        lex: &mut ::logos::Lexer<'s, Self>,
    ) -> std::option::Option<std::result::Result<Self, Self::Error>> {
        use ::logos::internal::{
            LexerInternal, CallbackRetVal, CallbackResult, SkipRetVal, SkipResult,
        };
        use std::result::Result as _Result;
        use std::option::Option as _Option;
        use ::logos::Logos;
        type _Lexer<'s> = ::logos::Lexer<'s, Token>;
        macro_rules! _fast_loop {
            ($lex:ident, $test:ident, $offset:ident) => {
                'fast_loop : { while let Some(arr) = $lex .read:: < & [u8; 8usize] >
                ($offset) { if $test (arr[0usize]) { $offset += 0usize; break 'fast_loop;
                } if $test (arr[1usize]) { $offset += 1usize; break 'fast_loop; } if
                $test (arr[2usize]) { $offset += 2usize; break 'fast_loop; } if $test
                (arr[3usize]) { $offset += 3usize; break 'fast_loop; } if $test
                (arr[4usize]) { $offset += 4usize; break 'fast_loop; } if $test
                (arr[5usize]) { $offset += 5usize; break 'fast_loop; } if $test
                (arr[6usize]) { $offset += 6usize; break 'fast_loop; } if $test
                (arr[7usize]) { $offset += 7usize; break 'fast_loop; } $offset += 8usize;
                } while let Some(byte) = $lex .read:: < u8 > ($offset) { if $test (byte)
                { break 'fast_loop; } $offset += 1; } }
            };
        }
        #[inline]
        fn _make_error<'s>(lex: &mut _Lexer<'s>) -> <Token as Logos<'s>>::Error {
            <Token as Logos<'s>>::Error::default()
        }
        #[derive(Clone, Copy)]
        enum LogosState {
            state0,
            state1,
            state10,
            state11,
            state12,
            state13,
            state14,
            state15,
            state16,
            state17,
            state18,
            state19,
            state2,
            state3,
            state4,
            state5,
            state6,
            state7,
            state8,
            state9,
        }
        let mut state = LogosState::state0;
        let mut offset = lex.offset();
        loop {
            match state {
                LogosState::state0 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        const TABLE: [_Option<LogosState>; 256] = [
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state2),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state1),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state4),
                            Some(LogosState::state5),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state7),
                            Some(LogosState::state6),
                            Some(LogosState::state6),
                            Some(LogosState::state8),
                            Some(LogosState::state9),
                            Some(LogosState::state9),
                            Some(LogosState::state9),
                            Some(LogosState::state10),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                            Some(LogosState::state3),
                        ];
                        let next_state = TABLE[byte as usize];
                        if let Some(next_state) = next_state {
                            offset += 1;
                            state = next_state;
                            continue;
                        }
                    } else {
                        if lex.offset() == offset {
                            return None;
                        }
                    }
                    lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
                    return Some(Err(_make_error(lex)));
                }
                LogosState::state1 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::AnyUnicode));
                }
                LogosState::state2 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::Newline));
                }
                LogosState::state3 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 255u8)) {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state4 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 127u8))
                            || (matches!(byte, 192u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state17;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
                    return Some(Err(_make_error(lex)));
                }
                LogosState::state5 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 159u8))
                            || (matches!(byte, 192u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 160u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state13;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state6 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 127u8))
                            || (matches!(byte, 192u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state13;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state7 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 127u8))
                            || (matches!(byte, 160u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 128u8..= 159u8)) {
                            offset += 1;
                            state = LogosState::state13;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state8 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 143u8))
                            || (matches!(byte, 192u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 144u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state12;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state9 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 127u8))
                            || (matches!(byte, 192u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state12;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state10 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 0u8..= 127u8))
                            || (matches!(byte, 144u8..= 255u8))
                        {
                            offset += 1;
                            state = LogosState::state11;
                            continue;
                        }
                        if (matches!(byte, 128u8..= 143u8)) {
                            offset += 1;
                            state = LogosState::state12;
                            continue;
                        }
                    } else {
                        offset += 1;
                        state = LogosState::state11;
                        continue;
                    }
                    return Some(Ok(Token::Any));
                }
                LogosState::state11 => {
                    lex.end(offset - 1);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::Any));
                }
                LogosState::state12 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state13;
                            continue;
                        }
                    } else {}
                    return Some(Ok(Token::Any));
                }
                LogosState::state13 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state1;
                            continue;
                        }
                    } else {}
                    return Some(Ok(Token::Any));
                }
                LogosState::state14 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::AnyUnicode));
                }
                LogosState::state15 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::AnyUnicode));
                }
                LogosState::state16 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (matches!(byte, 128u8..= 191u8)) {
                            offset += 1;
                            state = LogosState::state1;
                            continue;
                        }
                    } else {}
                    return Some(Ok(Token::Any));
                }
                LogosState::state17 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::AnyUnicode));
                }
                LogosState::state18 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::Newline));
                }
                LogosState::state19 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {} else {}
                    return Some(Ok(Token::AnyUnicode));
                }
            }
        }
    }
}

---
source: logos-codegen/tests/codegen.rs
expression: formatted
---
impl<'s> ::logos::Logos<'s> for Token {
    type Error = ();
    type Extras = ();
    type Source = [u8];
    fn lex(
        lex: &mut ::logos::Lexer<'s, Self>,
    ) -> std::option::Option<std::result::Result<Self, Self::Error>> {
        use ::logos::internal::{
            LexerInternal, CallbackRetVal, CallbackResult, SkipRetVal, SkipResult,
        };
        use std::result::Result as _Result;
        use std::option::Option as _Option;
        use ::logos::Logos;
        type _Lexer<'s> = ::logos::Lexer<'s, Token>;
        macro_rules! _fast_loop {
            ($lex:ident, $test:ident, $offset:ident) => {
                'fast_loop : { while let Some(arr) = $lex .read:: < & [u8; 8usize] >
                ($offset) { if $test (arr[0usize]) { $offset += 0usize; break 'fast_loop;
                } if $test (arr[1usize]) { $offset += 1usize; break 'fast_loop; } if
                $test (arr[2usize]) { $offset += 2usize; break 'fast_loop; } if $test
                (arr[3usize]) { $offset += 3usize; break 'fast_loop; } if $test
                (arr[4usize]) { $offset += 4usize; break 'fast_loop; } if $test
                (arr[5usize]) { $offset += 5usize; break 'fast_loop; } if $test
                (arr[6usize]) { $offset += 6usize; break 'fast_loop; } if $test
                (arr[7usize]) { $offset += 7usize; break 'fast_loop; } $offset += 8usize;
                } while let Some(byte) = $lex .read:: < u8 > ($offset) { if $test (byte)
                { break 'fast_loop; } $offset += 1; } }
            };
        }
        #[inline]
        fn _make_error<'s>(lex: &mut _Lexer<'s>) -> <Token as Logos<'s>>::Error {
            <Token as Logos<'s>>::Error::default()
        }
        fn state0<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                enum LogosNextState {
                    state1,
                    state2,
                    state3,
                    state4,
                    state5,
                    state6,
                    state7,
                    state8,
                    state9,
                    state10,
                }
                const TABLE: [_Option<LogosNextState>; 256] = [
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state2),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state1),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state4),
                    Some(LogosNextState::state5),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state7),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state6),
                    Some(LogosNextState::state8),
                    Some(LogosNextState::state9),
                    Some(LogosNextState::state9),
                    Some(LogosNextState::state9),
                    Some(LogosNextState::state10),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                    Some(LogosNextState::state3),
                ];
                match TABLE[byte as usize] {
                    Some(LogosNextState::state1) => {
                        offset += 1;
                        return state1(lex, offset);
                    }
                    Some(LogosNextState::state2) => {
                        offset += 1;
                        return state2(lex, offset);
                    }
                    Some(LogosNextState::state3) => {
                        offset += 1;
                        return state3(lex, offset);
                    }
                    Some(LogosNextState::state4) => {
                        offset += 1;
                        return state4(lex, offset);
                    }
                    Some(LogosNextState::state5) => {
                        offset += 1;
                        return state5(lex, offset);
                    }
                    Some(LogosNextState::state6) => {
                        offset += 1;
                        return state6(lex, offset);
                    }
                    Some(LogosNextState::state7) => {
                        offset += 1;
                        return state7(lex, offset);
                    }
                    Some(LogosNextState::state8) => {
                        offset += 1;
                        return state8(lex, offset);
                    }
                    Some(LogosNextState::state9) => {
                        offset += 1;
                        return state9(lex, offset);
                    }
                    Some(LogosNextState::state10) => {
                        offset += 1;
                        return state10(lex, offset);
                    }
                    None => {}
                }
            } else {
                if lex.offset() == offset {
                    return None;
                }
            }
            lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
            return Some(Err(_make_error(lex)));
        }
        fn state1<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::AnyUnicode));
        }
        fn state2<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::Newline));
        }
        fn state3<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::Any));
        }
        fn state4<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state1(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state5<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 160u8..= 191u8)) {
                    offset += 1;
                    return state13(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state6<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state13(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state7<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 159u8)) {
                    offset += 1;
                    return state13(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state8<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 144u8..= 191u8)) {
                    offset += 1;
                    return state12(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state9<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state12(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state10<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 143u8)) {
                    offset += 1;
                    return state12(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state11<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::Any));
        }
        fn state12<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state13(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state13<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state1(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state14<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::AnyUnicode));
        }
        fn state15<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::AnyUnicode));
        }
        fn state16<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {
                if (matches!(byte, 128u8..= 191u8)) {
                    offset += 1;
                    return state1(lex, offset);
                }
            } else {}
            return Some(Ok(Token::Any));
        }
        fn state17<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            lex.end(offset);
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::AnyUnicode));
        }
        fn state18<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::Newline));
        }
        fn state19<'s>(
            lex: &mut _Lexer<'s>,
            mut offset: usize,
        ) -> _Option<_Result<Token, <Token as Logos<'s>>::Error>> {
            let other = lex.read::<u8>(offset);
            if let Some(byte) = other {} else {}
            return Some(Ok(Token::AnyUnicode));
        }
        state0(lex, lex.offset())
    }
}

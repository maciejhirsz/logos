---
source: logos-cli/tests/tests.rs
expression: output
---
#[derive(Debug, Clone, Copy, PartialEq)]
enum Token {
    Letter,
}
impl<'s> ::logos::Logos<'s> for Token {
    type Error = ();
    type Extras = ();
    type Source = str;
    fn lex(
        lex: &mut ::logos::Lexer<'s, Self>,
    ) -> std::option::Option<std::result::Result<Self, Self::Error>> {
        use logos::internal::{
            CallbackResult, CallbackRetVal, LexerInternal, SkipResult, SkipRetVal,
        };
        use logos::Logos;
        use std::option::Option as _Option;
        use std::result::Result as _Result;
        type _Lexer<'s> = ::logos::Lexer<'s, Token>;
        macro_rules! _fast_loop {
            ($ lex : ident , $ test : ident , $ offset : ident) => {
                'fast_loop: {
                    while let Some(arr) = $lex.read::<&[u8; 8usize]>($offset) {
                        if $test(arr[0usize]) {
                            $offset += 0usize;
                            break 'fast_loop;
                        }
                        if $test(arr[1usize]) {
                            $offset += 1usize;
                            break 'fast_loop;
                        }
                        if $test(arr[2usize]) {
                            $offset += 2usize;
                            break 'fast_loop;
                        }
                        if $test(arr[3usize]) {
                            $offset += 3usize;
                            break 'fast_loop;
                        }
                        if $test(arr[4usize]) {
                            $offset += 4usize;
                            break 'fast_loop;
                        }
                        if $test(arr[5usize]) {
                            $offset += 5usize;
                            break 'fast_loop;
                        }
                        if $test(arr[6usize]) {
                            $offset += 6usize;
                            break 'fast_loop;
                        }
                        if $test(arr[7usize]) {
                            $offset += 7usize;
                            break 'fast_loop;
                        }
                        $offset += 8usize;
                    }
                    while let Some(byte) = $lex.read::<u8>($offset) {
                        if $test(byte) {
                            break 'fast_loop;
                        }
                        $offset += 1;
                    }
                }
            };
        }
        #[inline]
        fn _make_error<'s>(lex: &mut _Lexer<'s>) -> <Token as Logos<'s>>::Error {
            <Token as Logos<'s>>::Error::default()
        }
        #[derive(Clone, Copy)]
        enum LogosState {
            state0,
            state1,
            state2,
            state3,
        }
        let mut state = LogosState::state0;
        let mut offset = lex.offset();
        loop {
            match state {
                LogosState::state0 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (byte == b'a') {
                            offset += 1;
                            state = LogosState::state1;
                            continue;
                        }
                    } else {
                        if lex.offset() == offset {
                            return None;
                        }
                    }
                    lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
                    return Some(Err(_make_error(lex)));
                }
                LogosState::state1 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (byte == b'-') {
                            offset += 1;
                            state = LogosState::state2;
                            continue;
                        }
                    } else {
                    }
                    lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
                    return Some(Err(_make_error(lex)));
                }
                LogosState::state2 => {
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                        if (byte == b'z') {
                            offset += 1;
                            state = LogosState::state3;
                            continue;
                        }
                    } else {
                    }
                    lex.end_to_boundary(offset + if other.is_some() { 1 } else { 0 });
                    return Some(Err(_make_error(lex)));
                }
                LogosState::state3 => {
                    lex.end(offset);
                    let other = lex.read::<u8>(offset);
                    if let Some(byte) = other {
                    } else {
                    }
                    return Some(Ok(Token::Letter));
                }
            }
        }
    }
}

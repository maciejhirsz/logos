---
source: logos-codegen/tests/codegen.rs
expression: generated
---
impl < 's > :: logos :: Logos < 's > for Token { type Error = () ; type Extras = () ; type Source = [u8] ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) -> std :: option :: Option < std :: result :: Result < Self , Self :: Error >> { use :: logos :: internal :: { LexerInternal , CallbackRetVal , CallbackResult , SkipRetVal , SkipResult , } ; use :: logos :: Logos ; type Error = () ; type Lexer < 's > = :: logos :: Lexer < 's , Token > ; # [inline] fn make_error < 's > (lex : & mut Lexer < 's >) -> < Token as Logos < 's >> :: Error { < Token as Logos > :: Error :: default () } # [derive (Clone , Copy)] enum LogosState { State10240 , State1024Ctx2 , State10752 , State1536Ctx2 , State2048Ctx1 , State2560Ctx2 , State3072Ctx2 , State3584Ctx0 , State4096Ctx1 , State4608 , State5120 , State5632 , State6144 , State6656 , State7168 , State7680Ctx2 , State8192Ctx2 , State8704 , State9216 , State9728 } const START : LogosState = LogosState :: State4608 ; let mut state = START ; let mut offset = lex . offset () ; loop { match state { LogosState :: State1024Ctx2 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State1536Ctx2 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State7680Ctx2 ; } , other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State2048Ctx1 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { other => { return Some (Ok (Token :: AnyUnicode)) ; } } } LogosState :: State2560Ctx2 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State8192Ctx2 ; } , other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State3072Ctx2 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State2048Ctx1 ; } , None => { offset += 1 ; state = LogosState :: State2048Ctx1 ; } other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State3584Ctx0 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { other => { return Some (Ok (Token :: Newline)) ; } } } LogosState :: State4096Ctx1 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { other => { return Some (Ok (Token :: AnyUnicode)) ; } } } LogosState :: State4608 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 9u8) | Some (11u8 ..= 127u8) => { offset += 1 ; state = LogosState :: State7168 ; } , Some (10u8) => { offset += 1 ; state = LogosState :: State8704 ; } , Some (128u8 ..= 193u8) | Some (245u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State9216 ; } , Some (194u8 ..= 223u8) => { offset += 1 ; state = LogosState :: State9728 ; } , Some (224u8) => { offset += 1 ; state = LogosState :: State10240 ; } , Some (225u8 ..= 236u8) | Some (238u8 ..= 239u8) => { offset += 1 ; state = LogosState :: State10752 ; } , Some (237u8) => { offset += 1 ; state = LogosState :: State6656 ; } , Some (240u8) => { offset += 1 ; state = LogosState :: State5120 ; } , Some (241u8 ..= 243u8) => { offset += 1 ; state = LogosState :: State5632 ; } , Some (244u8) => { offset += 1 ; state = LogosState :: State6144 ; } , None => return None , other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State5120 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 143u8) | Some (192u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (144u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State1536Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State5632 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 127u8) | Some (192u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State1536Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State6144 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 127u8) | Some (144u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (128u8 ..= 143u8) => { offset += 1 ; state = LogosState :: State1536Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State6656 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 127u8) | Some (160u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (128u8 ..= 159u8) => { offset += 1 ; state = LogosState :: State2560Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State7168 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State4096Ctx1 ; } , None => { offset += 1 ; state = LogosState :: State4096Ctx1 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State7680Ctx2 => { match lex . read :: < u8 > (offset) { Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State8192Ctx2 ; } , other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State8192Ctx2 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State2048Ctx1 ; } , None => { offset += 1 ; state = LogosState :: State2048Ctx1 ; } other => { return Some (Ok (Token :: Any)) ; } } } LogosState :: State8704 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State3584Ctx0 ; } , None => { offset += 1 ; state = LogosState :: State3584Ctx0 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State9216 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State9728 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 127u8) | Some (192u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State3072Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State10240 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 159u8) | Some (192u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (160u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State2560Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } LogosState :: State10752 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 127u8) | Some (192u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } , Some (128u8 ..= 191u8) => { offset += 1 ; state = LogosState :: State2560Ctx2 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx2 ; } other => { lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (make_error (lex))) ; } } } } } } }

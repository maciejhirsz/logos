---
source: logos-codegen/tests/codegen.rs
expression: generated
---
impl < 's > :: logos :: Logos < 's > for Token { type Error = &'static str ; type Extras = Vec <&'static str > ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) { use :: logos :: internal :: { LexerInternal , CallbackResult , SkipCallbackResult } ; type Lexer < 's > = :: logos :: Lexer < 's , Token > ; fn _end < 's > (lex : & mut Lexer < 's >) { lex . end () } fn _error < 's > (lex : & mut Lexer < 's >) { lex . bump_unchecked (1) ; lex . error () ; } macro_rules ! _fast_loop { ($ lex : ident , $ test : ident , $ miss : expr) => { while let Some (arr) = $ lex . read :: < & [u8 ; 16] > () { if $ test (arr [0]) { if $ test (arr [1]) { if $ test (arr [2]) { if $ test (arr [3]) { if $ test (arr [4]) { if $ test (arr [5]) { if $ test (arr [6]) { if $ test (arr [7]) { if $ test (arr [8]) { if $ test (arr [9]) { if $ test (arr [10]) { if $ test (arr [11]) { if $ test (arr [12]) { if $ test (arr [13]) { if $ test (arr [14]) { if $ test (arr [15]) { $ lex . bump_unchecked (16) ; continue ; } $ lex . bump_unchecked (15) ; return $ miss ; } $ lex . bump_unchecked (14) ; return $ miss ; } $ lex . bump_unchecked (13) ; return $ miss ; } $ lex . bump_unchecked (12) ; return $ miss ; } $ lex . bump_unchecked (11) ; return $ miss ; } $ lex . bump_unchecked (10) ; return $ miss ; } $ lex . bump_unchecked (9) ; return $ miss ; } $ lex . bump_unchecked (8) ; return $ miss ; } $ lex . bump_unchecked (7) ; return $ miss ; } $ lex . bump_unchecked (6) ; return $ miss ; } $ lex . bump_unchecked (5) ; return $ miss ; } $ lex . bump_unchecked (4) ; return $ miss ; } $ lex . bump_unchecked (3) ; return $ miss ; } $ lex . bump_unchecked (2) ; return $ miss ; } $ lex . bump_unchecked (1) ; return $ miss ; } return $ miss ; } while $ lex . test ($ test) { $ lex . bump_unchecked (1) ; } $ miss } ; } # [inline] fn goto5_x < 's > (lex : & mut Lexer < 's >) { labelled_callback (lex) . construct_skip (lex) ; } # [inline] fn goto7_x < 's > (lex : & mut Lexer < 's >) { labelled_skip_callback (lex) . construct_skip (lex) ; } # [inline] fn goto1_x < 's > (lex : & mut Lexer < 's >) { lex . trivia () ; Token :: lex (lex) ; } # [inline] fn goto9_x < 's > (lex : & mut Lexer < 's >) { labelled_result_callback (lex) . construct_skip (lex) ; } # [inline] fn goto3_x < 's > (lex : & mut Lexer < 's >) { fn callback < 's > (lex : & mut Lexer) -> impl SkipCallbackResult < 's , Token > + use < 's > { lex . extras . push ("inline_callback") } callback (lex) . construct_skip (lex) ; } # [inline] fn goto11_x < 's > (lex : & mut Lexer < 's >) { labelled_skip_result_callback (lex) . construct_skip (lex) ; } # [inline] fn goto13 < 's > (lex : & mut Lexer < 's >) { enum Jump { __ , J5 , J7 , J1 , J9 , J3 , J11 , } const LUT : [Jump ; 256] = { use Jump :: * ; [__ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , J1 , J3 , J5 , J7 , J9 , J9 , J11 , J11 , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __ , __] } ; let byte = match lex . read :: < u8 > () { Some (byte) => byte , None => return _end (lex) , } ; match LUT [byte as usize] { Jump :: J5 => { lex . bump_unchecked (1usize) ; goto5_x (lex) } , Jump :: J7 => { lex . bump_unchecked (1usize) ; goto7_x (lex) } , Jump :: J1 => { lex . bump_unchecked (1usize) ; goto1_x (lex) } , Jump :: J9 => { lex . bump_unchecked (1usize) ; goto9_x (lex) } , Jump :: J3 => { lex . bump_unchecked (1usize) ; goto3_x (lex) } , Jump :: J11 => { lex . bump_unchecked (1usize) ; goto11_x (lex) } , Jump :: __ => _error (lex) } } goto13 (lex) } }

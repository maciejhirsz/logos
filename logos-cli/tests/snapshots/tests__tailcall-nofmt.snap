---
source: logos-cli/tests/tests.rs
expression: output
---
# [derive (Debug , Clone , Copy , PartialEq)] enum Token { Letter , }impl < 's > :: logos :: Logos < 's > for Token { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) -> std :: option :: Option < std :: result :: Result < Self , Self :: Error >> { use :: logos :: internal :: { LexerInternal , CallbackRetVal , CallbackResult , SkipRetVal , SkipResult , } ; use std :: result :: Result as _Result ; use std :: option :: Option as _Option ; use :: logos :: Logos ; type _Lexer < 's > = :: logos :: Lexer < 's , Token > ; macro_rules ! _fast_loop { ($ lex : ident , $ test : ident , $ offset : ident) => { 'fast_loop : { while let Some (arr) = $ lex . read :: < & [u8 ; 8usize] > ($ offset) { if $ test (arr [0usize]) { $ offset += 0usize ; break 'fast_loop ; } if $ test (arr [1usize]) { $ offset += 1usize ; break 'fast_loop ; } if $ test (arr [2usize]) { $ offset += 2usize ; break 'fast_loop ; } if $ test (arr [3usize]) { $ offset += 3usize ; break 'fast_loop ; } if $ test (arr [4usize]) { $ offset += 4usize ; break 'fast_loop ; } if $ test (arr [5usize]) { $ offset += 5usize ; break 'fast_loop ; } if $ test (arr [6usize]) { $ offset += 6usize ; break 'fast_loop ; } if $ test (arr [7usize]) { $ offset += 7usize ; break 'fast_loop ; } $ offset += 8usize ; } while let Some (byte) = $ lex . read :: < u8 > ($ offset) { if $ test (byte) { break 'fast_loop ; } $ offset += 1 ; } } } ; } # [inline] fn _make_error < 's > (lex : & mut _Lexer < 's >) -> < Token as Logos < 's >> :: Error { < Token as Logos < 's >> :: Error :: default () } fn state0 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'a') { offset += 1 ; return state1 (lex , offset) ; } } else { if lex . offset () == offset { return None } } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } fn state1 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'-') { offset += 1 ; return state2 (lex , offset) ; } } else { } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } fn state2 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { if (byte == b'z') { offset += 1 ; return state3 (lex , offset) ; } } else { } lex . end_to_boundary (offset + if other . is_some () { 1 } else { 0 }) ; return Some (Err (_make_error (lex))) ; } fn state3 < 's > (lex : & mut _Lexer < 's > , mut offset : usize) -> _Option < _Result < Token , < Token as Logos < 's >> :: Error >> { lex . end (offset) ; let other = lex . read :: < u8 > (offset) ; if let Some (byte) = other { } else { } return Some (Ok (Token :: Letter)) ; } state0 (lex , lex . offset ()) } }

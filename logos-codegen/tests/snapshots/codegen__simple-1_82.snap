---
source: logos-codegen/tests/codegen.rs
expression: generated
---
impl < 's > :: logos :: Logos < 's > for Token { type Error = () ; type Extras = () ; type Source = str ; fn lex (lex : & mut :: logos :: Lexer < 's , Self >) -> Option < Result < Self , Self :: Error >> { use :: logos :: internal :: { LexerInternal , CallbackRetVal , CallbackResult , SkipRetVal , SkipResult , } ; use :: logos :: Logos ; type Lexer < 's > = :: logos :: Lexer < 's , Token > ; # [derive (Clone , Copy)] enum LogosState { State1024Ctx0 , State1536 , State2048 , State2560 , State3072 } const START : LogosState = LogosState :: State1536 ; let mut state = START ; let mut offset = lex . offset () ; loop { match state { LogosState :: State1024Ctx0 => { lex . end (offset - 1) ; match lex . read :: < u8 > (offset) { _ => { return Some (Ok (Token :: Letter)) ; } } } LogosState :: State1536 => { match lex . read :: < u8 > (offset) { Some (b'a') => { offset += 1 ; state = LogosState :: State3072 ; } , None => return None , _ => { lex . end_to_boundary (offset + 1) ; return Some (Err (Self :: Error :: default ())) ; } } } LogosState :: State2048 => { match lex . read :: < u8 > (offset) { Some (b'z') => { offset += 1 ; state = LogosState :: State2560 ; } , _ => { lex . end_to_boundary (offset + 1) ; return Some (Err (Self :: Error :: default ())) ; } } } LogosState :: State2560 => { match lex . read :: < u8 > (offset) { Some (0u8 ..= 255u8) => { offset += 1 ; state = LogosState :: State1024Ctx0 ; } , None => { offset += 1 ; state = LogosState :: State1024Ctx0 ; } _ => { lex . end_to_boundary (offset + 1) ; return Some (Err (Self :: Error :: default ())) ; } } } LogosState :: State3072 => { match lex . read :: < u8 > (offset) { Some (b'-') => { offset += 1 ; state = LogosState :: State2048 ; } , _ => { lex . end_to_boundary (offset + 1) ; return Some (Err (Self :: Error :: default ())) ; } } } } } } }
